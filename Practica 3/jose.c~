// Practica tema 7, del Val Acebes Jose Alberto


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <string.h>

#define MAXDATASIZE 516

int main(int argc, char *argv[]){

	//COmprobamos el numero de argumentos
	if(argc<4||argc>5) {
		printf("Ha introducido un nÃºmero de argumentos no valido.\n");
		exit(1);
	}

	char buf[MAXDATASIZE]; //recibir datos
	int sockcl; //descriptor socket
	struct sockaddr_in dir; //direccion servidor
	struct sockaddr_in cli; //direccion cliente
	struct servent *serv; //obtener puerto servidor
	//Rellenamos la estructura del cliente
	FILE *fp;

	cli.sin_family=AF_INET;
	cli.sin_port=0;
	cli.sin_addr.s_addr=INADDR_ANY;


	//Abrimos el socket del cliente
	if ((sockcl = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
 		perror("socket()");
 		exit(1);
 	}
	//Dir servidor.

	dir.sin_family=AF_INET;
	serv=getservbyname ("tftp","udp");
	int puerto;
	puerto = serv->s_port; //Se tiene el puerto
	printf("puerto : %d\n",puerto);



	//Estructua almacenar ip en la estructura de la direccion

	struct in_addr dirip;

	if(inet_aton(argv[1],&dirip)==-1){
		perror("inet_aton()");
		exit(0);
	}

	dir.sin_addr=dirip;

	//Obtenemos el modo de lectura y nombre del archivo.
	char modo[MAXDATASIZE];
	char opcode[2];

	strcpy(modo,argv[2]);
	char narchivo[100];

	fflush(stdout);
	strcpy(narchivo,argv[3]);
	char paquete[25];

	//Enlazamos el socket con su estructura.

	if(bind(sockcl,(struct sockaddr*)&cli,sizeof(cli))==-1) {
      		perror("bind()");
      		exit(0);

	}


	//modo lectura
	if(strcmp(modo,"-r")==0){
		strcpy(opcode,"01");
	}
	//modo escritura
	else{
		strcpy(opcode,"02");

	}
	//Formamos el paquete de peticion en opcode

	strcat(opcode,narchivo);
	strcat(opcode,"0");
	strcat(opcode,"octet");
	strcat(opcode,"0");

	strcpy(paquete,opcode);
	printf("%s\n",paquete);
	fflush(stdout);
	//Peticion al server
	if(sendto(sockcl,paquete,MAXDATASIZE,0,(struct sockaddr*)&dir,sizeof(dir))==-1){
		perror("sendto()");
      		exit(0);
	}
	printf("envio peticion modo\n");
	fflush(stdout);

	//Modo lectura


	//Abrimos fichero
	if((fp = fopen ( "fichero.txt", "w" ))==NULL){
		perror("fopen()");
		exit(0);
	}
	printf("fichero abierto\n");
	fflush(stdout);

	int longitud=512;
	char bloque[2]="";
	int bloq=0;
	int baux=0;
	char bufaux[MAXDATASIZE];

	do{
		//Recibimos paquete
		printf("recibimos paquete\n");
		fflush(stdout);

		if(recvfrom(sockcl,buf,MAXDATASIZE,0,NULL,NULL)==-1){
			perror("recvfrom()");
	      		exit(0);

		}
		printf("ya esta recibido\n");
		fflush(stdout);
		longitud=strlen(buf);
		strcpy(opcode,&buf[0]);
		strcat(opcode,&buf[1]);
		//Paquete datos
		if(strcmp(opcode,"03")){
			strcpy(bloque,&buf[2]);
			strcat(bloque,&buf[3]);
			bloq=atoi(bloque);
			char ack[4]="";
 			/*if(bloq>baux){
				//TRATAR DESORDEN
			}*/
			//Escribimos en fichero el bloque que toca.
			//else{
				printf("escribimos en fichero");
				fflush(stdout);

				fwrite( &buf[4], sizeof(char), 512, fp );
				strcpy(ack,"04");
				strcat(ack,bloque);
			//}
			if(sendto(sockcl,ack,4,0,(struct sockaddr*)&dir,sizeof(dir))==-1){
				perror("sendto()");
		      		exit(0);
			}


		}
		//Error
		else{
			//CREAR EL METODO QUE IMPRIME EL ERROR POR PANTALLA
			//muestraerror();
			exit(0);
		}



}while(longitud==512);




	//Imprimimos el resultado
	printf("%s",buf);
	//Cerramos el socket porque ya no le vamos a utilizar mas
	close (sockcl);
	return 0;

}
